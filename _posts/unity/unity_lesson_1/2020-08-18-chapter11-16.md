---
title:  "Unity Chapter 11-16. ì¢€ë¹„ TPS ê²Œì„ ë§Œë“¤ê¸° : Enemy" 

categories:
  -  Unity Lesson 1 
tags:
  - [Game Engine, Unity]

toc: true
toc_sticky: true

date: 2020-08-18
last_modified_at: 2020-08-18
---

ì¸í”„ëŸ°ì— ìˆëŠ” ì´ì œë¯¼ë‹˜ì˜ **ë ˆíŠ¸ë¡œì˜ ìœ ë‹ˆí‹° C# ê²Œì„ í”„ë¡œê·¸ë˜ë° ì—ì„¼ìŠ¤** ê°•ì˜ë¥¼ ë“£ê³  ì •ë¦¬í•œ í•„ê¸°ì…ë‹ˆë‹¤. ğŸ˜€  
[ğŸŒœ [ë ˆíŠ¸ë¡œì˜ ìœ ë‹ˆí‹° C# ê²Œì„ í”„ë¡œê·¸ë˜ë° ì—ì„¼ìŠ¤] ê°•ì˜ ë“¤ìœ¼ëŸ¬ ê°€ê¸°!](https://www.inflearn.com/course/%EC%9C%A0%EB%8B%88%ED%8B%B0-%EA%B2%8C%EC%9E%84-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%97%90%EC%84%BC%EC%8A%A4)
{: .notice--warning}

<br>

# Chapter 11. ì¢€ë¹„ TPS ê²Œì„ ë§Œë“¤ê¸° 

## ğŸ“œEnemy.cs

> `Zombie`ì— ë¶™ì—¬ì¤€ë‹¤.

- ì¢€ë¹„ ìºë¦­í„°ì˜ <u>ìƒëª…ì²´ë¡œì„œì˜ ë™ì‘</u>ì„ ë‹´ë‹¹
  - <u>LivingEntityë¥¼ ìƒì† ë°›ì•„ ìƒì† ë°›ì€ ìƒëª…ì²´ë¡œì„œì˜ ê¸°ë³¸ ë™ì‘ ê·¸ ìœ„ì— ì¢€ë¹„ë§Œì˜ ë™ì‘ì„ êµ¬í˜„í•  ê²ƒì´ë‹¤.</u>
    - LivingEntity ìœ„ì—ì„œ í™•ì¥ë§Œ í•˜ë©´ ë¨

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

#if UNITY_EDITOR
using UnityEditor;
#endif

public class Enemy : LivingEntity
{
    private enum State
    {
        Patrol,
        Tracking,
        AttackBegin,
        Attacking
    }

    private State state;

    private NavMeshAgent agent; // ê²½ë¡œê³„ì‚° AI ì—ì´ì „íŠ¸
    private Animator animator; // ì• ë‹ˆë©”ì´í„° ì»´í¬ë„ŒíŠ¸

    public Transform attackRoot;
    public Transform eyeTransform;

    private AudioSource audioPlayer; // ì˜¤ë””ì˜¤ ì†ŒìŠ¤ ì»´í¬ë„ŒíŠ¸
    public AudioClip hitClip; // í”¼ê²©ì‹œ ì¬ìƒí•  ì†Œë¦¬
    public AudioClip deathClip; // ì‚¬ë§ì‹œ ì¬ìƒí•  ì†Œë¦¬

    private Renderer skinRenderer; // ë Œë”ëŸ¬ ì»´í¬ë„ŒíŠ¸

    public float runSpeed = 10f;
    [Range(0.01f, 2f)] public float turnSmoothTime = 0.1f;
    private float turnSmoothVelocity;

    public float damage = 30f;
    public float attackRadius = 2f;
    private float attackDistance;

    public float fieldOfView = 50f;
    public float viewDistance = 10f;
    public float patrolSpeed = 3f;

    [HideInInspector] public LivingEntity targetEntity; // ì¶”ì í•  ëŒ€ìƒ
    public LayerMask whatIsTarget; // ì¶”ì  ëŒ€ìƒ ë ˆì´ì–´


    private RaycastHit[] hits = new RaycastHit[10];
    private List<LivingEntity> lastAttackedTargets = new List<LivingEntity>();

    private bool hasTarget => targetEntity != null && !targetEntity.dead;


#if UNITY_EDITOR

    private void OnDrawGizmosSelected()
    {
        if (attackRoot != null)
        {
            Gizmos.color = new Color(1f, 0f, 0f, 0.5f);
            Gizmos.DrawSphere(attackRoot.position, attackRadius);
        }

        var leftRayRotation = Quaternion.AngleAxis(-fieldOfView * 0.5f, Vector3.up);
        var leftRayDirection = leftRayRotation * transform.forward;
        Handles.color = new Color(1f, 1f, 1f, 0.2f);
        Handles.DrawSolidArc(eyeTransform.position, Vector3.up, leftRayDirection, fieldOfView, viewDistance);
    }

#endif

    private void Awake()
    {
        agent = GetComponent<NavMeshAgent>();
        animator = GetComponent<Animator>();
        audioPlayer = GetComponent<AudioSource>();
        skinRenderer = GetComponentInChildren<Renderer>();

        attackDistance = Vector3.Distance(transform.position,
                             new Vector3(attackRoot.position.x, transform.position.y, attackRoot.position.z)) +
                         attackRadius;

        attackDistance += agent.radius;

        agent.stoppingDistance = attackDistance;
        agent.speed = patrolSpeed;
    }

    // ì  AIì˜ ì´ˆê¸° ìŠ¤í™ì„ ê²°ì •í•˜ëŠ” ì…‹ì—… ë©”ì„œë“œ
    public void Setup(float health, float damage,
        float runSpeed, float patrolSpeed, Color skinColor)
    {
        // ì²´ë ¥ ì„¤ì •
        this.startingHealth = health;
        this.health = health;

        // ë‚´ë¹„ë©”ì‰¬ ì—ì´ì „íŠ¸ì˜ ì´ë™ ì†ë„ ì„¤ì •
        this.runSpeed = runSpeed;
        this.patrolSpeed = patrolSpeed;

        this.damage = damage;

        // ë Œë”ëŸ¬ê°€ ì‚¬ìš©ì¤‘ì¸ ë¨¸í…Œë¦¬ì–¼ì˜ ì»¬ëŸ¬ë¥¼ ë³€ê²½, ì™¸í˜• ìƒ‰ì´ ë³€í•¨
        skinRenderer.material.color = skinColor;
    }

    private void Start()
    {
        // ê²Œì„ ì˜¤ë¸Œì íŠ¸ í™œì„±í™”ì™€ ë™ì‹œì— AIì˜ ì¶”ì  ë£¨í‹´ ì‹œì‘
        StartCoroutine(UpdatePath());
    }

    private void Update()
    {
        if (dead) return;

        if (state == State.Tracking &&
            Vector3.Distance(targetEntity.transform.position, transform.position) <= attackDistance)
        {
            BeginAttack();
        }


        // ì¶”ì  ëŒ€ìƒì˜ ì¡´ì¬ ì—¬ë¶€ì— ë”°ë¼ ë‹¤ë¥¸ ì• ë‹ˆë©”ì´ì…˜ì„ ì¬ìƒ
        animator.SetFloat("Speed", agent.desiredVelocity.magnitude);
    }

    private void FixedUpdate()
    {
        if (dead) return;


        if (state == State.AttackBegin || state == State.Attacking)
        {
            var lookRotation =
                Quaternion.LookRotation(targetEntity.transform.position - transform.position, Vector3.up);
            var targetAngleY = lookRotation.eulerAngles.y;

            transform.eulerAngles = Vector3.up * Mathf.SmoothDampAngle(transform.eulerAngles.y, targetAngleY,
                                        ref turnSmoothVelocity, turnSmoothTime);
        }

        if (state == State.Attacking)
        {
            var direction = transform.forward;
            var deltaDistance = agent.velocity.magnitude * Time.deltaTime;

            var size = Physics.SphereCastNonAlloc(attackRoot.position, attackRadius, direction, hits, deltaDistance,
                whatIsTarget);

            for (var i = 0; i < size; i++)
            {
                var attackTargetEntity = hits[i].collider.GetComponent<LivingEntity>();

                if (attackTargetEntity != null && !lastAttackedTargets.Contains(attackTargetEntity))
                {
                    var message = new DamageMessage();
                    message.amount = damage;
                    message.damager = gameObject;
                    message.hitPoint = attackRoot.TransformPoint(hits[i].point);
                    message.hitNormal = attackRoot.TransformDirection(hits[i].normal);

                    attackTargetEntity.ApplyDamage(message);

                    lastAttackedTargets.Add(attackTargetEntity);
                    break;
                }
            }
        }
    }

    // ì£¼ê¸°ì ìœ¼ë¡œ ì¶”ì í•  ëŒ€ìƒì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ ê²½ë¡œë¥¼ ê°±ì‹ 
    private IEnumerator UpdatePath()
    {
        // ì‚´ì•„ìˆëŠ” ë™ì•ˆ ë¬´í•œ ë£¨í”„
        while (!dead)
        {
            if (hasTarget)
            {
                if (state == State.Patrol)
                {
                    state = State.Tracking;
                    agent.speed = runSpeed;
                }

                // ì¶”ì  ëŒ€ìƒ ì¡´ì¬ : ê²½ë¡œë¥¼ ê°±ì‹ í•˜ê³  AI ì´ë™ì„ ê³„ì† ì§„í–‰
                agent.SetDestination(targetEntity.transform.position);
            }
            else
            {
                if (targetEntity != null) targetEntity = null;

                if (state != State.Patrol)
                {
                    state = State.Patrol;
                    agent.speed = patrolSpeed;
                }

                if (agent.remainingDistance <= 1f)
                {
                    var patrolPosition = Utility.GetRandomPointOnNavMesh(transform.position, 20f, NavMesh.AllAreas);
                    agent.SetDestination(patrolPosition);
                }

                // 20 ìœ ë‹›ì˜ ë°˜ì§€ë¦„ì„ ê°€ì§„ ê°€ìƒì˜ êµ¬ë¥¼ ê·¸ë ¸ì„ë•Œ, êµ¬ì™€ ê²¹ì¹˜ëŠ” ëª¨ë“  ì½œë¼ì´ë”ë¥¼ ê°€ì ¸ì˜´
                // ë‹¨, whatIsTarget ë ˆì´ì–´ë¥¼ ê°€ì§„ ì½œë¼ì´ë”ë§Œ ê°€ì ¸ì˜¤ë„ë¡ í•„í„°ë§
                var colliders = Physics.OverlapSphere(eyeTransform.position, viewDistance, whatIsTarget);

                // ëª¨ë“  ì½œë¼ì´ë”ë“¤ì„ ìˆœíšŒí•˜ë©´ì„œ, ì‚´ì•„ìˆëŠ” LivingEntity ì°¾ê¸°
                foreach (var collider in colliders)
                {
                    if (!IsTargetOnSight(collider.transform)) break;

                    var livingEntity = collider.GetComponent<LivingEntity>();

                    // LivingEntity ì»´í¬ë„ŒíŠ¸ê°€ ì¡´ì¬í•˜ë©°, í•´ë‹¹ LivingEntityê°€ ì‚´ì•„ìˆë‹¤ë©´,
                    if (livingEntity != null && !livingEntity.dead)
                    {
                        // ì¶”ì  ëŒ€ìƒì„ í•´ë‹¹ LivingEntityë¡œ ì„¤ì •
                        targetEntity = livingEntity;

                        // forë¬¸ ë£¨í”„ ì¦‰ì‹œ ì •ì§€
                        break;
                    }
                }
            }

            // 0.2 ì´ˆ ì£¼ê¸°ë¡œ ì²˜ë¦¬ ë°˜ë³µ
            yield return new WaitForSeconds(0.2f);
        }
    }

    // ë°ë¯¸ì§€ë¥¼ ì…ì—ˆì„ë•Œ ì‹¤í–‰í•  ì²˜ë¦¬
    public override bool ApplyDamage(DamageMessage damageMessage)
    {
        if (!base.ApplyDamage(damageMessage)) return false;

        if (targetEntity == null)
        {
            targetEntity = damageMessage.damager.GetComponent<LivingEntity>();
        }

        EffectManager.Instance.PlayHitEffect(damageMessage.hitPoint, damageMessage.hitNormal, transform, EffectManager.EffectType.Flesh);
        audioPlayer.PlayOneShot(hitClip);

        return true;
    }

    public void BeginAttack()
    {
        state = State.AttackBegin;

        agent.isStopped = true;
        animator.SetTrigger("Attack");
    }

    public void EnableAttack()
    {
        state = State.Attacking;

        lastAttackedTargets.Clear();
    }

    public void DisableAttack()
    {
        state = State.Tracking;

        agent.isStopped = false;
    }

    private bool IsTargetOnSight(Transform target)
    {
        RaycastHit hit;

        var direction = target.position - eyeTransform.position;

        direction.y = eyeTransform.forward.y;

        if (Vector3.Angle(direction, eyeTransform.forward) > fieldOfView * 0.5f)
        {
            return false;
        }

        if (Physics.Raycast(eyeTransform.position, direction, out hit, viewDistance, whatIsTarget))
        {
            if (hit.transform == target) return true;
        }

        return false;
    }

    // ì‚¬ë§ ì²˜ë¦¬
    public override void Die()
    {
        // LivingEntityì˜ Die()ë¥¼ ì‹¤í–‰í•˜ì—¬ ê¸°ë³¸ ì‚¬ë§ ì²˜ë¦¬ ì‹¤í–‰
        base.Die();

        // ë‹¤ë¥¸ AIë“¤ì„ ë°©í•´í•˜ì§€ ì•Šë„ë¡ ìì‹ ì˜ ëª¨ë“  ì½œë¼ì´ë”ë“¤ì„ ë¹„í™œì„±í™”
        GetComponent<Collider>().enabled = false;

        // AI ì¶”ì ì„ ì¤‘ì§€í•˜ê³  ë‚´ë¹„ë©”ì‰¬ ì»´í¬ë„ŒíŠ¸ë¥¼ ë¹„í™œì„±í™”
        agent.enabled = false;

        // ì‚¬ë§ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
        animator.applyRootMotion = true;
        animator.SetTrigger("Die");

        // ì‚¬ë§ íš¨ê³¼ìŒ ì¬ìƒ
        if (deathClip != null) audioPlayer.PlayOneShot(deathClip);
    }
}
```

<br>

### ì‹œì‘í•˜ê¸° ì•ì„œ

#### UnityEngine.AI

```c#
using UnityEngine.AI
```

- ë„¤ë¹„ê²Œì´ì…˜ ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„  `UnityEngine.AI` ì„ ì¸í´ë£¨ë”© í•´ì¤˜ì•¼ í•œë‹¤.

<br>

#### ì „ì²˜ë¦¬ê¸°

```c#
#if UNITY_EDITOR
using UnityEditor;
#endif
```

> UnityEditor ì˜ ê¸°ëŠ¥ë“¤ì„ ì‚¬ìš©í•  ë•ŒëŠ” `using UnityEditor`ë§Œ í•´ì£¼ë©´ ì•ˆë˜ê³  ë°˜ë“œì‹œ ì „ì²˜ë¦¬ê¸° `#if UNITY_EDITOR`, `#endif` ì•ˆì— ë„£ì–´ì„œ ì„ ì–¸í•´ì£¼ì–´ì•¼ í•œë‹¤.

- <u>ì˜¤ì§ ìœ ë‹ˆí‹° ì—ë””í„°ì—ì„œë§Œ</u> `UnityEditor` ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ê² ë‹¤ê³  ì„ ì–¸.
  - ìœ ë‹ˆí‹° ì—ë””í„° ë‚´ì—ì„œë§Œ ë™ì‘í•  ë¿ `UnityEditor` ë„¤ì„ìŠ¤í˜ì´ìŠ¤ê°€ ë¹Œë“œ ë˜ì§€ëŠ” ì•ŠëŠ”ë‹¤.
    - ê²Œì„ ê°œë°œì´ ì™„ì„±ëœ í›„ ë‚˜ì¤‘ì— ìœˆë„ìš°ìš©, ë§¥OS, ì•ˆë“œë¡œì´ë“œ ë“±ë“± ì´ëŸ° ë‹¤ì–‘í•œ í”Œë«í¼ìœ¼ë¡œì„œ ë¹Œë“œ í•  ë•Œ ì´ ë¶€ë¶„ì€ ë¹Œë“œì—ì„œ ë¹ ì§€ê²Œ ëœë‹¤. ìœ ë‹ˆí‹° ì—ë””í„°ì—ì„œë§Œ ë˜ë‹ˆê¹Œ!
  - ì˜¤ë¡œì§€ ìœ ë‹ˆí‹° ì—ë””í„°ì—ì„œë§Œ ì¢€ë¹„ê°€ í”Œë ˆì´ì–´ë¥¼ ì¸ì‹í•  ìˆ˜ ìˆëŠ” ì˜ì—­ì„ ì‹œê°ì ìœ¼ë¡œ ë³´ì—¬ì£¼ê¸° ìœ„í•´ì„œ ì´ì— ëŒ€í•œ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” `UnityEditor` ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ë˜ ì˜¤ì§ ìœ ë‹ˆí‹° ì—ë””í„°ì—ì„œë§Œ ì‚¬ìš©!

> **ì „ì²˜ë¦¬ê¸°** ğŸ‘‰ íŠ¹ì • ìƒí™©ì— ë”°ë¼ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì»´íŒŒì¼í• ì§€ ë§ì§€ ê²°ì •í•  ìˆ˜ ìˆë‹¤.

- ìœ ë‹ˆí‹°ëŠ” ì—¬ëŸ¬ í”Œë«í¼ì„ ë¹Œë“œí•  ìˆ˜ ìˆë‹¤. iOS, ì•ˆë“œë¡œì´ë“œ, ìœˆë„ìš°, ë§¥OS ë“±ë“±..
  - í”Œë«í¼ì— ë”°ë¥¸ ê°ê°ì˜ ì½”ë“œë“¤ì„ ë§Œë“¤ ë•Œ <u>íŠ¹ì • í”Œë«í¼ì—ë§Œ ì»´íŒŒì¼ ë˜ëŠ” ì „ì²˜ë¦¬ê¸°ë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.</u>
  - ì˜ˆë¥¼ë“¤ì–´ iOS ì „ì²˜ë¦¬ê¸° ë¶€ë¶„ì€ ê²Œì„ ê°œë°œì´ ì™„ì„±ëœ í›„ iOSë¡œ ë¹Œë“œë  ë•Œë§Œ í¬í•¨ëœë‹¤. ì•ˆë“œë¡œì´ë“œë¡œ ë¹Œë“œ ë  ë•ŒëŠ” ì´ ë¶€ë¶„ì˜ ì½”ë“œê°€ ë¹Œë“œì— í¬í•¨ë˜ì§€ ì•ŠëŠ”ë‹¤.

 ```c#
    #if UNITY_EDITOR 
      Debug.Log("Unity Editor");  // ìœ ë‹ˆí‹° ì—ë””í„°ì—ì„œë§Œ ë‚˜ì˜¤ëŠ” ë¡œê·¸
    #endif
    
    #if UNITY_IOS
      Debug.Log("Iphone");   // iOS ì—ì„œë§Œ ë‚˜ì˜¤ëŠ” ë¡œê·¸. iOSë¡œ ë¹Œë“œí•  ë•Œë§Œ ë¹Œë“œ ëœë‹¤.
    #endif

    #if UNITY_STANDALONE_OSX
    Debug.Log("Stand Alone OSX");   // ë§¥ OS ì—ì„œë§Œ ë‚˜ì˜¤ëŠ” ë¡œê·¸. ë§¥ OSë¡œ ë¹Œë“œí•  ë•Œë§Œ ë¹Œë“œ ëœë‹¤.
    #endif

    #if UNITY_STANDALONE_WIN
      Debug.Log("Stand Alone Windows");  // ìœˆë„ìš°ì—ì„œë§Œ ë‚˜ì˜¤ëŠ” ë¡œê·¸. ìœˆë„ìš°ë¡œ ë¹Œë“œí•  ë•Œë§Œ ë¹Œë“œ ëœë‹¤.
    #endif
```

<br>

### ë©¤ë²„ ë³€ìˆ˜/í”„ë¡œí¼í‹°

> LivingEntityë¥¼ ìƒì† ë°›ì•˜ìœ¼ë¯€ë¡œ <u>LivingEntityì˜ ë©¤ë²„ ë³€ìˆ˜ë“¤ë„ ê°€ì§€ê³  ìˆë‹¤ëŠ” ê²ƒ ìŠì§€ ë§ê¸°!</u>

```c#
    private enum State  // ì¢€ë¹„ ìƒíƒœ
    {
        Patrol,      // ëŒì•„ë‹¤ë‹ˆëŠ” ìƒíƒœ
        Tracking,    // í”Œë ˆì´ì–´ë¥¼ ì¶”ê²©í•˜ëŠ” ìƒíƒœ
        AttackBegin, // ê³µê²© ì‹œì‘
        Attacking    // ê³µê²©
    }

    private State state;  // ì¢€ë¹„ ìƒíƒœ

    private NavMeshAgent agent; // NavMeshAgent ê²½ë¡œê³„ì‚° AI ì—ì´ì „íŠ¸
    private Animator animator; // ì¢€ë¹„ ì• ë‹ˆë©”ì´ì…˜ì„ í‘œí˜„í•  ì• ë‹ˆë©”ì´í„° ì»´í¬ë„ŒíŠ¸

    public Transform attackRoot;  
    public Transform eyeTransform;

    private AudioSource audioPlayer; // ì˜¤ë””ì˜¤ ì†ŒìŠ¤ ì»´í¬ë„ŒíŠ¸. ì†Œë¦¬ ì¬ìƒê¸°
    public AudioClip hitClip; // í”¼ê²©ì‹œ ì¬ìƒí•  ì†Œë¦¬
    public AudioClip deathClip; // ì‚¬ë§ì‹œ ì¬ìƒí•  ì†Œë¦¬

    private Renderer skinRenderer; // ë Œë”ëŸ¬ ì»´í¬ë„ŒíŠ¸

    public float runSpeed = 10f;  // ì¢€ë¹„ ì´ë™ ì†ë„
    [Range(0.01f, 2f)] public float turnSmoothTime = 0.1f;  // ì¢€ë¹„ê°€ ë°©í–¥ì„ ìŠ¤ë¬´ìŠ¤í•˜ê²Œ íšŒì „í•  ë•Œ ì‚¬ìš©í•  ì§€ì—°ì‹œê°„. smoothDamp ì— ì‚¬ìš©í• ê²ƒ. 
    private float turnSmoothVelocity; // smoothDamp ì— ì‚¬ìš©í• ê²ƒ. ìŠ¤ë¬´ìŠ¤í•˜ê²Œ íšŒì „í•˜ëŠ” ì‹¤ì‹œê°„ ë³€í™”ëŸ‰

    public float damage = 30f;  // ê³µê²©ë ¹
    public float attackRadius = 2f; // ê³µê²© ë°˜ê²½(ë°˜ì§€ë¦„)
    private float attackDistance; // ê³µê²©ì„ ì‹œë„í•˜ëŠ” ê±°ë¦¬

    public float fieldOfView = 50f;  // ì¢€ë¹„ì˜ ì‹œì•¼ ê°
    public float viewDistance = 10f; // ì¢€ë¹„ê°€ ë³¼ ìˆ˜ ìˆëŠ” ê±°ë¦¬
    public float patrolSpeed = 3f; // ì¢€ë¹„ê°€ ëŒì•„ë‹¤ë‹ˆëŠ” ê±°ë¦¬(Patrol ìƒíƒœì¼ ë•Œ)

    [HideInInspector] public LivingEntity targetEntity; // ì¶”ì í•  ëŒ€ìƒ. 
    public LayerMask whatIsTarget; // ì¶”ì  ëŒ€ìƒ ë ˆì´ì–´


    private RaycastHit[] hits = new RaycastHit[10];
    private List<LivingEntity> lastAttackedTargets = new List<LivingEntity>();

    private bool hasTarget => targetEntity != null && !targetEntity.dead;
```

- í•„ê¸° ì•ˆí•œê±´ ì£¼ì„ ì°¸ê³ 
- `attackRoot`
  - **Transform**
  - ì¢€ë¹„ ì˜¤ë¸Œì íŠ¸ê°€ ê³µê²©ì„ í•˜ëŠ” Pivot í¬ì¸íŠ¸. 
  - ì´ `attackRoo`tì„ ì¤‘ì‹¬ìœ¼ë¡œ ë°˜ì§€ë¦„ì„ ì§€ì •í•´ì„œ ì´ ë°˜ê²½ ë‚´ì— ìˆëŠ” í”Œë ˆì´ì–´ê°€ ê³µê²©ì„ ë‹¹í•˜ë„ë¡ í•  ê²ƒì´ë‹¤.
- `eyeTransform`
  - **Transform**
  - ì‹œì•¼ì˜ ê¸°ì¤€ì . 'ëˆˆì˜ ìœ„ì¹˜'ê°€ ë  ì–´ë–¤ ê²Œì„ ì˜¤ë¸Œì íŠ¸ì˜ Trnasform
  - ì´ `eyeTransform`ì„ ê¸°ì¤€ìœ¼ë¡œ ì–´ë–¤ ì˜ì—­ì„ ì§€ì •í•´ì„œ í”Œë ˆì´ì–´ë‚˜ ì  AIë¥¼ ê°ì§€í•  ìˆ˜ ìˆê²Œ í•  ê²ƒì´ë‹¤.
- `skinRenderer`
  - **Renderer**
  - ì¢€ë¹„ì˜ í”¼ë¶€ìƒ‰ì— ë”°ë¼ì„œ ê³µê²©ë ¥ì„ ë‹¤ë¥´ê²Œ í•´ì¤„ ê²ƒ
    - ê·¸ë•Œ ì‚¬ìš©í•  í”¼ë¶€ìƒ‰!
- `targetEntity`
  - **LivingEntity**
  - ì¢€ë¹„ê°€ ì¶”ì í•  ëŒ€ìƒ. 
  - í”Œë ˆì´ì–´ ìºë¦­í„° ì˜¤ë¸Œì íŠ¸ê°€ ì´ ê³³ì— í• ë‹¹ ë  ê²ƒ! 
  - LivingEntity íƒ€ì…ì´ë¼ë©´ ì–´ë–¤ ê²ƒì´ë“ ì§€ ì´ ê³³ì— í• ë‹¹ ê°€ëŠ¥.
  - `[HideInInspector]` ë¼ì„œ ìœ ë‹ˆí‹° ì¸ìŠ¤í™í„° ì°½ì—ì„  ë³´ì´ì§€ ì•ŠìŒ. publicì¸ë°ë„ ë¶ˆêµ¬í•˜ê³ !
    - ì½”ë“œë¡œ í• ë‹¹ í•  ê²ƒì´ë¼ì„œ ìˆ¨ê²¼ë‹¤.
- `whatIsTarget`
  - **LayerMask**
  - ì ì„ ê°ì§€í•  ë•Œ ì‚¬ìš©í•  ë ˆì´ì–´ í•„í„°
- `hits`
  - 10 ì‚¬ì´ì¦ˆì˜ <u>RaycastHit ë°°ì—´</u>ì´ë‹¤.
    - ë°°ì—´ì„ ì‚¬ìš©í•œ ì´ìœ 
      - ì¢€ë¹„ì˜ ê³µê²©ì„ ë²”ìœ„ ê¸°ë°˜ì˜ ê³µê²©ìœ¼ë¡œ êµ¬í˜„í•  ê²ƒì´ë¼ì„œ ë²”ìœ„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©´ ì—¬ëŸ¬ê°œì˜ Ray ì¶©ëŒ ì§€ì ì´ ìƒê¸°ê¸° ë•Œë¬¸.
- `lastAttackedTargets`
  - LivingEntity íƒ€ì…ì˜ ì›ì†Œë“¤ì´ ë“¤ì–´ê°€ ë¦¬ìŠ¤íŠ¸
    - ê³µê²©ì„ ì‹œì‘í•  ë•Œë§ˆë‹¤ ì´ˆê¸°í™” ë  ë¦¬ìŠ¤íŠ¸
    - ê³µê²© ë„ì¤‘ì— <u>ì§ì „ í”„ë ˆì„ê¹Œì§€ ê³µê²©ì´ ì ìš©ëœ ëŒ€ìƒë“¤ì„ ëª¨ì•„ë‘˜ ë¦¬ìŠ¤íŠ¸</u>
      - ê³µê²©ì€ ì‹œê°„ì„ ë“¤ì—¬ì„œ ì§„í–‰ ë˜ëŠ”ë°, <u>ê³µê²©ì´ ë˜‘ê°™ì€ ëŒ€ìƒì—ê²Œ ë‘ë²ˆ ì´ìƒ ì ìš©ë˜ì§€ ì•Šë„ë¡ í•˜ê¸° ìœ„í•˜ì—¬</u> ì´ ë¦¬ìŠ¤íŠ¸ì— í¬í•¨ëœ ì¢€ë¹„ë“¤ì€ ê³µê²© ëŒ€ìƒì—ì„œ ì œì™¸í•  ê²ƒì´ë‹¤.
- `hasTarget`
  - ì¶”ì í•  ëŒ€ìƒì´ ì¡´ì¬í•˜ëŠ”ì§€ì˜ ì—¬ë¶€
  - ëŒë‹¤ í•¨ìˆ˜ë¡œ ì •ì˜ëœ í”„ë¡œí¼í‹°
    - *targetEntity != null && !targetEntity.dead*
      - ì¶”ì í•  ìƒëŒ€ë°©ì´ ì¡´ì¬í•˜ê³  ì¶”ì í•  ìƒëŒ€ë°©ì´ ì£½ì€ ìƒíƒœê°€ ì•„ë‹ˆë¼ë©´
  

<br>

### ë©¤ë²„ í•¨ìˆ˜

#### private void OnDrawGizmosSelected()

```c#
#if UNITY_EDITOR

    private void OnDrawGizmosSelected()
    {
        if (attackRoot != null)
        {
            Gizmos.color = new Color(1f, 0f, 0f, 0.5f);
            Gizmos.DrawSphere(attackRoot.position, attackRadius);
        }

        var leftRayRotation = Quaternion.AngleAxis(-fieldOfView * 0.5f, Vector3.up);
        var leftRayDirection = leftRayRotation * transform.forward;
        Handles.color = new Color(1f, 1f, 1f, 0.2f);
        Handles.DrawSolidArc(eyeTransform.position, Vector3.up, leftRayDirection, fieldOfView, viewDistance);
    }

#endif
```

<br>

#### private void Awake()

```c#
    private void Awake()
    {
        agent = GetComponent<NavMeshAgent>();
        animator = GetComponent<Animator>();
        audioPlayer = GetComponent<AudioSource>();
        skinRenderer = GetComponentInChildren<Renderer>();

        attackDistance = Vector3.Distance(transform.position,
                             new Vector3(attackRoot.position.x, transform.position.y, attackRoot.position.z)) +
                         attackRadius;

        attackDistance += agent.radius;

        agent.stoppingDistance = attackDistance;
        agent.speed = patrolSpeed;
    }
```

<br>

#### public void Setup(float health, float damage, float runSpeed, float patrolSpeed, Color skinColor)

```c#
    // ì  AIì˜ ì´ˆê¸° ìŠ¤í™ì„ ê²°ì •í•˜ëŠ” ì…‹ì—… ë©”ì„œë“œ
    public void Setup(float health, float damage,
        float runSpeed, float patrolSpeed, Color skinColor)
    {
        // ì²´ë ¥ ì„¤ì •
        this.startingHealth = health;
        this.health = health;

        // ë‚´ë¹„ë©”ì‰¬ ì—ì´ì „íŠ¸ì˜ ì´ë™ ì†ë„ ì„¤ì •
        this.runSpeed = runSpeed;
        this.patrolSpeed = patrolSpeed;

        this.damage = damage;

        // ë Œë”ëŸ¬ê°€ ì‚¬ìš©ì¤‘ì¸ ë¨¸í…Œë¦¬ì–¼ì˜ ì»¬ëŸ¬ë¥¼ ë³€ê²½, ì™¸í˜• ìƒ‰ì´ ë³€í•¨
        skinRenderer.material.color = skinColor;
    }
```

<br>

#### private void Start()

```c#
    private void Start()
    {
        // ê²Œì„ ì˜¤ë¸Œì íŠ¸ í™œì„±í™”ì™€ ë™ì‹œì— AIì˜ ì¶”ì  ë£¨í‹´ ì‹œì‘
        StartCoroutine(UpdatePath());
    }
```

<br>

#### private void Update()

```c#
    private void Update()
    {
        if (dead) return;

        if (state == State.Tracking &&
            Vector3.Distance(targetEntity.transform.position, transform.position) <= attackDistance)
        {
            BeginAttack();
        }


        // ì¶”ì  ëŒ€ìƒì˜ ì¡´ì¬ ì—¬ë¶€ì— ë”°ë¼ ë‹¤ë¥¸ ì• ë‹ˆë©”ì´ì…˜ì„ ì¬ìƒ
        animator.SetFloat("Speed", agent.desiredVelocity.magnitude);
    }
```

<br>

#### private void FixedUpdate()

```c#
    private void FixedUpdate()
    {
        if (dead) return;


        if (state == State.AttackBegin || state == State.Attacking)
        {
            var lookRotation =
                Quaternion.LookRotation(targetEntity.transform.position - transform.position, Vector3.up);
            var targetAngleY = lookRotation.eulerAngles.y;

            transform.eulerAngles = Vector3.up * Mathf.SmoothDampAngle(transform.eulerAngles.y, targetAngleY,
                                        ref turnSmoothVelocity, turnSmoothTime);
        }

        if (state == State.Attacking)
        {
            var direction = transform.forward;
            var deltaDistance = agent.velocity.magnitude * Time.deltaTime;

            var size = Physics.SphereCastNonAlloc(attackRoot.position, attackRadius, direction, hits, deltaDistance,
                whatIsTarget);

            for (var i = 0; i < size; i++)
            {
                var attackTargetEntity = hits[i].collider.GetComponent<LivingEntity>();

                if (attackTargetEntity != null && !lastAttackedTargets.Contains(attackTargetEntity))
                {
                    var message = new DamageMessage();
                    message.amount = damage;
                    message.damager = gameObject;
                    message.hitPoint = attackRoot.TransformPoint(hits[i].point);
                    message.hitNormal = attackRoot.TransformDirection(hits[i].normal);

                    attackTargetEntity.ApplyDamage(message);

                    lastAttackedTargets.Add(attackTargetEntity);
                    break;
                }
            }
        }
    }
```

<br>

#### private IEnumerator UpdatePath()

```c#
    // ì£¼ê¸°ì ìœ¼ë¡œ ì¶”ì í•  ëŒ€ìƒì˜ ìœ„ì¹˜ë¥¼ ì°¾ì•„ ê²½ë¡œë¥¼ ê°±ì‹ 
    private IEnumerator UpdatePath()
    {
        // ì‚´ì•„ìˆëŠ” ë™ì•ˆ ë¬´í•œ ë£¨í”„
        while (!dead)
        {
            if (hasTarget)
            {
                if (state == State.Patrol)
                {
                    state = State.Tracking;
                    agent.speed = runSpeed;
                }

                // ì¶”ì  ëŒ€ìƒ ì¡´ì¬ : ê²½ë¡œë¥¼ ê°±ì‹ í•˜ê³  AI ì´ë™ì„ ê³„ì† ì§„í–‰
                agent.SetDestination(targetEntity.transform.position);
            }
            else
            {
                if (targetEntity != null) targetEntity = null;

                if (state != State.Patrol)
                {
                    state = State.Patrol;
                    agent.speed = patrolSpeed;
                }

                if (agent.remainingDistance <= 1f)
                {
                    var patrolPosition = Utility.GetRandomPointOnNavMesh(transform.position, 20f, NavMesh.AllAreas);
                    agent.SetDestination(patrolPosition);
                }

                // 20 ìœ ë‹›ì˜ ë°˜ì§€ë¦„ì„ ê°€ì§„ ê°€ìƒì˜ êµ¬ë¥¼ ê·¸ë ¸ì„ë•Œ, êµ¬ì™€ ê²¹ì¹˜ëŠ” ëª¨ë“  ì½œë¼ì´ë”ë¥¼ ê°€ì ¸ì˜´
                // ë‹¨, whatIsTarget ë ˆì´ì–´ë¥¼ ê°€ì§„ ì½œë¼ì´ë”ë§Œ ê°€ì ¸ì˜¤ë„ë¡ í•„í„°ë§
                var colliders = Physics.OverlapSphere(eyeTransform.position, viewDistance, whatIsTarget);

                // ëª¨ë“  ì½œë¼ì´ë”ë“¤ì„ ìˆœíšŒí•˜ë©´ì„œ, ì‚´ì•„ìˆëŠ” LivingEntity ì°¾ê¸°
                foreach (var collider in colliders)
                {
                    if (!IsTargetOnSight(collider.transform)) break;

                    var livingEntity = collider.GetComponent<LivingEntity>();

                    // LivingEntity ì»´í¬ë„ŒíŠ¸ê°€ ì¡´ì¬í•˜ë©°, í•´ë‹¹ LivingEntityê°€ ì‚´ì•„ìˆë‹¤ë©´,
                    if (livingEntity != null && !livingEntity.dead)
                    {
                        // ì¶”ì  ëŒ€ìƒì„ í•´ë‹¹ LivingEntityë¡œ ì„¤ì •
                        targetEntity = livingEntity;

                        // forë¬¸ ë£¨í”„ ì¦‰ì‹œ ì •ì§€
                        break;
                    }
                }
            }

            // 0.2 ì´ˆ ì£¼ê¸°ë¡œ ì²˜ë¦¬ ë°˜ë³µ
            yield return new WaitForSeconds(0.2f);
        }
    }
```

<br>

#### public override bool ApplyDamage(DamageMessage damageMessage)

```c#
    // ë°ë¯¸ì§€ë¥¼ ì…ì—ˆì„ë•Œ ì‹¤í–‰í•  ì²˜ë¦¬
    public override bool ApplyDamage(DamageMessage damageMessage)
    {
        if (!base.ApplyDamage(damageMessage)) return false;

        if (targetEntity == null)
        {
            targetEntity = damageMessage.damager.GetComponent<LivingEntity>();
        }

        EffectManager.Instance.PlayHitEffect(damageMessage.hitPoint, damageMessage.hitNormal, transform, EffectManager.EffectType.Flesh);
        audioPlayer.PlayOneShot(hitClip);

        return true;
    }
```

<br>

#### public void BeginAttack()

```c#
    public void BeginAttack()
    {
        state = State.AttackBegin;

        agent.isStopped = true;
        animator.SetTrigger("Attack");
    }
```

<br>

#### public void EnableAttack()

```c#
    public void EnableAttack()
    {
        state = State.Attacking;

        lastAttackedTargets.Clear();
    }
```

<br>

#### public void DisableAttack()

```c#
    public void DisableAttack()
    {
        state = State.Tracking;

        agent.isStopped = false;
    }
```

<br>

#### private bool IsTargetOnSight(Transform target)

```c#
    private bool IsTargetOnSight(Transform target)
    {
        RaycastHit hit;

        var direction = target.position - eyeTransform.position;

        direction.y = eyeTransform.forward.y;

        if (Vector3.Angle(direction, eyeTransform.forward) > fieldOfView * 0.5f)
        {
            return false;
        }

        if (Physics.Raycast(eyeTransform.position, direction, out hit, viewDistance, whatIsTarget))
        {
            if (hit.transform == target) return true;
        }

        return false;
    }
```

<br>

#### public override void Die()

```c#
    // ì‚¬ë§ ì²˜ë¦¬
    public override void Die()
    {
        // LivingEntityì˜ Die()ë¥¼ ì‹¤í–‰í•˜ì—¬ ê¸°ë³¸ ì‚¬ë§ ì²˜ë¦¬ ì‹¤í–‰
        base.Die();

        // ë‹¤ë¥¸ AIë“¤ì„ ë°©í•´í•˜ì§€ ì•Šë„ë¡ ìì‹ ì˜ ëª¨ë“  ì½œë¼ì´ë”ë“¤ì„ ë¹„í™œì„±í™”
        GetComponent<Collider>().enabled = false;

        // AI ì¶”ì ì„ ì¤‘ì§€í•˜ê³  ë‚´ë¹„ë©”ì‰¬ ì»´í¬ë„ŒíŠ¸ë¥¼ ë¹„í™œì„±í™”
        agent.enabled = false;

        // ì‚¬ë§ ì• ë‹ˆë©”ì´ì…˜ ì¬ìƒ
        animator.applyRootMotion = true;
        animator.SetTrigger("Die");

        // ì‚¬ë§ íš¨ê³¼ìŒ ì¬ìƒ
        if (deathClip != null) audioPlayer.PlayOneShot(deathClip);
    }
}
```

***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}

<br>