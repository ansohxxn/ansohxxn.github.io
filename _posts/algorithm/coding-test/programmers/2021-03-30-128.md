---
title:  "[C++ë¡œ í’€ì´] ë¸”ë¡ ì´ë™í•˜ê¸° (BFS, í•´ì‹œ í•¨ìˆ˜)â­â­â­" 

categories:
  - Programmers
tags:
  - [Algorithm, Coding Test]

toc: true
toc_sticky: true

date: 2021-03-30
last_modified_at: 2021-03-30
---
**C++**ë¡œ í’€ì´í–ˆìŠµë‹ˆë‹¤.  
ì¶œì²˜ : **í”„ë¡œê·¸ë˜ë¨¸ìŠ¤** <https://programmers.co.kr/learn/challenges>
{: .notice--warning}

# ğŸ“Œ ë¸”ë¡ ì´ë™í•˜ê¸°

## ğŸš€ ë¬¸ì œ

![image](https://user-images.githubusercontent.com/42318591/112856838-2ce74380-90eb-11eb-9a7b-b57bdf174ad9.png)

![image](https://user-images.githubusercontent.com/42318591/112856878-383a6f00-90eb-11eb-96e4-fcfb3170eafe.png)

![image](https://user-images.githubusercontent.com/42318591/112856910-412b4080-90eb-11eb-8d10-7108c41d284c.png)


<br>

## ğŸš€ ë‚´ í’€ì´

![image](https://user-images.githubusercontent.com/42318591/113553513-dc17a380-9632-11eb-87ae-cd74af61cf83.png)

![image](https://user-images.githubusercontent.com/42318591/113553535-e3d74800-9632-11eb-9670-641b4c74e20e.png)


### ğŸ”¥ 3 ì°¨ì› ë°°ì—´ë¡œ ë°©ë¬¸ ì²´í¬í•œ í’€ì´ â­•

```cpp
#include <string>
#include <vector>
#include <queue>

using namespace std;

#define UP 0
#define DOWN 1
#define LEFT 2
#define RIGHT 3

// ìƒí•˜ì¢Œìš°
int dy[] = { -1, 1, 0, 0 };
int dx[] = { 0, 0, -1, 1 };
int N;

// í•˜ë‚˜ì˜ ìœ„ì¹˜ ì¢Œí‘œ
struct Pos {
    int y; // í–‰
    int x; // ì—´
    int dir; // ë¡œë´‡ì˜ ì¤‘ì‹¬ì—ì„œ ì–´ëŠìª½ì— ìˆëŠ”ì§€ ê·¸ ë°©í–¥ â­
};

// ë¡œë´‡
struct Robot {
    Pos part1; // ë¡œë´‡ì˜ ì¼ë¶€ 1 ì˜ ìœ„ì¹˜ì™€ ë°©í–¥
    Pos part2; // ë¡œë´‡ì˜ ì¼ë¶€ 2 ì˜ ìœ„ì¹˜ì™€ ë°©í–¥
    int time;  // í˜„ì¬ê¹Œì§€ ê±¸ë¦° ì‹œê°„
};

// ë‘ part1, part2 ìœ„ì¹˜ê°€ board ì—ì„œ ë²—ì–´ë‚œ ê³³ì€ ì•„ë‹Œì§€, ë²½ì€ ì•„ë‹Œì§€ ê²€ì‚¬
// ì¦‰ ê¸°ë³¸ì ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ê³³ì¸ì§€ ê²€ì‚¬
bool possible(vector<vector<int>> board, Pos part1, Pos part2) {
    // ë‘ ìœ„ì¹˜ ë‹¤ ë²”ìœ„ì—ì„œ ë²—ì–´ë‚œ ê³³ì¸ì§€
    if (part1.y < 0 || part1.y >= N || part1.x < 0 || part1.x >= N ||
        part2.y < 0 || part2.y >= N || part2.x < 0 || part2.x >= N)
        return false;
    // ë‘ ìœ„ì¹˜ ë‹¤ ë²½ì€ ì•„ë‹Œì§€
    if (board[part1.y][part1.x] == 1 ||
        board[part2.y][part2.x] == 1)
        return false;

    // ë‘ ìœ„ì¹˜ ëª¨ë‘ ë‹¤ ë²”ìœ„ ë‚´ + ë²½ì´ ì•„ë‹ˆë©´ true
    return true;
}

int solution(vector<vector<int>> board) {
    int answer = 0;
    N = board.size();
   
    queue<Robot> q;
    // í ì‚½ì…(ì˜ˆì•½) ì²´í¬ ë°°ì—´.
    // ë¡œë´‡ì€ ìœ„ì¹˜ ì¢Œí‘œë¥¼ 2 ê°œë¥¼ ì“°ê³ , ë˜í•œ íšŒì „ì„ í•˜ê¸° ë•Œë¬¸ì— ë°©ë¬¸ ì²´í¬ë¥¼ ë°©í–¥ê¹Œì§€ ë”í•œ 3ì°¨ì› ë°°ì—´ë¡œ í•œë‹¤.  
    bool checked[100][100][4] = { false }; 

    // ë¡œë´‡ì˜ ì‹œì‘ ìƒíƒœ
    // ì¼ë¶€1 : (0, 0) ë¡œë´‡ ì¤‘ì‹¬ì˜ ì™¼ìª½
    // ì¼ë¶€2 : (0, 1) ë¡œë´‡ ì¤‘ì‹¬ì˜ ì˜¤ë¥¸ìª½
    Robot start{ { 0, 0, LEFT }, { 0, 1, RIGHT }, 0 };
    checked[0][0][LEFT] = true; 
    checked[0][1][RIGHT] = true;
    q.push(start);

    while (!q.empty()) {
        // ë°©ë¬¸
        Robot now = q.front();
        q.pop();

        // ë¡œë´‡ì´ ëª©ì ì§€ì— ë„ì°©í–ˆë‹¤ë©´(ë¡œë´‡ì˜ ë‘ íŒŒíŠ¸ ì¤‘ í•˜ë‚˜ë¼ë„ ë„ì°©í–ˆë‹¤ë©´)
        if (now.part1.y == N - 1 && now.part1.x == N - 1 || now.part2.y == N - 1 && now.part2.x == N - 1) {
            answer = now.time;
            break;
        }
        
        /* ì˜ˆì•½ : ì´ë™ */
        for (int i = 0; i < 4; ++i) {
            Pos next_part_1{ now.part1.y + dy[i], now.part1.x + dx[i], now.part1.dir };
            Pos next_part_2{ now.part2.y + dy[i], now.part2.x + dx[i], now.part2.dir };
            
            if (!possible(board, next_part_1, next_part_2))
                continue;
            if (checked[next_part_1.y][next_part_1.x][next_part_1.dir] && checked[next_part_2.y][next_part_2.x][next_part_2.dir])
                continue;

            Robot next{ next_part_1, next_part_2, now.time + 1 };
            q.push(next);
            checked[next.part1.y][next.part1.x][next.part1.dir] = true; // íŒŒíŠ¸1 ì˜ˆì•½ ì²´í¬
            checked[next.part2.y][next.part2.x][next.part2.dir] = true; // íŒŒíŠ¸2 ì˜ˆì•½ ì²´í¬
        }

        /* ì˜ˆì•½ : íšŒì „ */
        if (now.part1.dir == LEFT) {
            Pos up_left{ now.part1.y - 1, now.part1.x, UP };
            Pos up_right{ now.part2.y - 1, now.part2.x, UP };
            if (possible(board, up_left, up_right)) {
                if (!checked[up_left.y][up_left.x][UP] || !checked[now.part1.y][now.part1.x][DOWN]) {
                    q.push({ up_left, { now.part1.y, now.part1.x, DOWN } , now.time + 1});
                    checked[up_left.y][up_left.x][UP] = true;
                    checked[now.part1.y][now.part1.x][DOWN] = true;
                }
                if (!checked[up_right.y][up_right.x][UP] || !checked[now.part2.y][now.part2.x][DOWN]) {
                    q.push({ up_right, { now.part2.y, now.part2.x, DOWN } , now.time + 1 });
                    checked[up_right.y][up_right.x][UP] = true;
                    checked[now.part2.y][now.part2.x][DOWN] = true;
                }
            }
            Pos down_left{ now.part1.y + 1, now.part1.x, DOWN };
            Pos down_right{ now.part2.y + 1, now.part2.x, DOWN };
            if (possible(board, down_left, down_right)) {
                if (!checked[down_left.y][down_left.x][DOWN] || !checked[now.part1.y][now.part1.x][UP]) {
                    q.push({ { now.part1.y, now.part1.x, UP } , down_left, now.time + 1 });
                    checked[down_left.y][down_left.x][DOWN] = true;
                    checked[now.part1.y][now.part1.x][UP] = true;
                }
                if (!checked[down_right.y][down_right.x][DOWN] || !checked[now.part2.y][now.part2.x][UP]) {
                    q.push({ { now.part2.y, now.part2.x, UP } , down_right, now.time + 1 });
                    checked[down_right.y][down_right.x][DOWN] = true;
                    checked[now.part2.y][now.part2.x][UP] = true;
                }
            }
        }
        if (now.part1.dir == UP) {
            Pos left_up{ now.part1.y, now.part1.x - 1, LEFT };
            Pos left_down{ now.part2.y, now.part2.x - 1, LEFT };
            if (possible(board, left_up, left_down)) {
                if (!checked[left_up.y][left_up.x][LEFT] || !checked[now.part1.y][now.part1.x][RIGHT]) {
                    q.push({ left_up, { now.part1.y, now.part1.x, RIGHT } , now.time + 1 });
                    checked[left_up.y][left_up.x][LEFT] = true;
                    checked[now.part1.y][now.part1.x][RIGHT] = true;
                }
                if (!checked[left_down.y][left_down.x][LEFT] || !checked[now.part2.y][now.part2.x][RIGHT]) {
                    q.push({ left_down, { now.part2.y, now.part2.x, RIGHT } , now.time + 1 });
                    checked[left_down.y][left_down.x][LEFT] = true;
                    checked[now.part2.y][now.part2.x][RIGHT] = true;
                }
            }
            Pos right_up{ now.part1.y, now.part1.x + 1, RIGHT };
            Pos right_down{ now.part2.y, now.part2.x + 1, RIGHT };
            if (possible(board, right_up, right_down)) {
                if (!checked[right_up.y][right_up.x][RIGHT] || !checked[now.part1.y][now.part1.x][LEFT]) {
                    q.push({ { now.part1.y, now.part1.x, LEFT } , right_up, now.time + 1 });
                    checked[right_up.y][right_up.x][RIGHT] = true;
                    checked[now.part1.y][now.part1.x][LEFT] = true;
                }
                if (!checked[right_down.y][right_down.x][RIGHT] || !checked[now.part2.y][now.part2.x][LEFT]) {
                    q.push({ { now.part2.y, now.part2.x, LEFT } , right_down, now.time + 1 });
                    checked[right_down.y][right_down.x][RIGHT] = true;
                    checked[now.part2.y][now.part2.x][LEFT] = true;
                }
            }
        }
    }

    return answer;
}
```

![image](https://user-images.githubusercontent.com/42318591/112876467-8443de80-9100-11eb-91e7-1d1a15ba3f12.png)

í˜„ì¬ì˜ ìœ„ì¹˜ì—ì„œ ë¡œë´‡ì´ 1ï¸âƒ£ í‰ë²”í•œ ì´ë™, 2ï¸âƒ£ íšŒì „ ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ìœ„ì¹˜ë“¤ì„ íì— ì‚½ì…í•˜ì—¬ ì˜ˆì•½í•˜ëŠ” ì‹ìœ¼ë¡œ BFS ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ë©´ ëœë‹¤! ì¤‘ìš”í•œì ì´ ìˆë‹¤ë©´ ì˜ˆì•½ ì²´í¬ë¥¼ í•  ë•Œ í–‰ ì—´ë³„ë¡œ ì €ì¥í•˜ëŠ” 2ì°¨ì› ë°°ì—´ì´ ì•„ë‹Œ, ë°©í–¥ê¹Œì§€ ê³ ë ¤í•˜ì—¬ 3ì°¨ì› ë°°ì—´ì„ ì‚¬ìš©í–ˆë‹¤ëŠ” ê²ƒì´ë‹¤. 

![image](https://user-images.githubusercontent.com/42318591/113552309-f486be80-9630-11eb-88c2-3e2adec32966.png)


<br>

### ğŸ”¥ í•´ì‹œë¥¼ ì‚¬ìš©í•˜ì—¬ ë°©ë¬¸ ì²´í¬í•œ í’€ì´(+ ì»¤ìŠ¤í…€ í•´ì‹œí•¨ìˆ˜) â­•

```cpp
#include <string>
#include <vector>
#include <unordered_set>
#include <queue>

using namespace std;

#define UP 0
#define DOWN 1
#define LEFT 2
#define RIGHT 3

// ìƒí•˜ì¢Œìš°
int dy[] = { -1, 1, 0, 0 };
int dx[] = { 0, 0, -1, 1 };
int N;

// í•˜ë‚˜ì˜ ìœ„ì¹˜ ì¢Œí‘œ
struct Pos {
    int y; // í–‰
    int x; // ì—´
    int dir; // ë¡œë´‡ì˜ ì¤‘ì‹¬ì—ì„œ ì–´ëŠìª½ì— ìˆëŠ”ì§€ ê·¸ ë°©í–¥ â­
};

// ë¡œë´‡
struct Robot {
    Pos part1; // ë¡œë´‡ì˜ ì¼ë¶€ 1 ì˜ ìœ„ì¹˜ì™€ ë°©í–¥
    Pos part2; // ë¡œë´‡ì˜ ì¼ë¶€ 2 ì˜ ìœ„ì¹˜ì™€ ë°©í–¥
    int time;  // í˜„ì¬ê¹Œì§€ ê±¸ë¦° ì‹œê°„

    // í•´ì‹œì— í•„ìš”í•œ == ì—°ì‚°ì ì˜¤ë²„ë¡œë”©
    bool operator == (const Robot& other) const {
        bool condition1 = part1.y == other.part1.y && part1.x == other.part1.x;
        bool condition2 = part2.y == other.part2.y && part2.x == other.part2.x;
        bool condition3 = part1.y == other.part2.y && part1.x == other.part2.x;
        bool condition4 = part2.y == other.part1.y && part2.x == other.part1.x;
        if (condition1 && condition2 || condition3 && condition4)
            return true;
        return false;
    }
};

// ì»¤ìŠ¤í…€ í•´ì‹œ í•¨ìˆ˜
struct MyHash {
    size_t operator()(const Robot& robot) const {
        hash<int> hash_func;
        return hash_func(robot.part1.y) ^ robot.part1.x ^ robot.part2.y + hash_func(robot.part2.x);
    }
};

// ë‘ part1, part2 ìœ„ì¹˜ê°€ board ì—ì„œ ë²—ì–´ë‚œ ê³³ì€ ì•„ë‹Œì§€, ë²½ì€ ì•„ë‹Œì§€ ê²€ì‚¬
// ì¦‰ ê¸°ë³¸ì ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ê³³ì¸ì§€ ê²€ì‚¬
bool possible(vector<vector<int>> board, Pos part1, Pos part2) {
    // ë‘ ìœ„ì¹˜ ë‹¤ ë²”ìœ„ì—ì„œ ë²—ì–´ë‚œ ê³³ì¸ì§€
    if (part1.y < 0 || part1.y >= N || part1.x < 0 || part1.x >= N ||
        part2.y < 0 || part2.y >= N || part2.x < 0 || part2.x >= N)
        return false;
    // ë‘ ìœ„ì¹˜ ë‹¤ ë²½ì€ ì•„ë‹Œì§€
    if (board[part1.y][part1.x] == 1 ||
        board[part2.y][part2.x] == 1)
        return false;

    // ë‘ ìœ„ì¹˜ ëª¨ë‘ ë‹¤ ë²”ìœ„ ë‚´ + ë²½ì´ ì•„ë‹ˆë©´ true
    return true;
}

int solution(vector<vector<int>> board) {
    int answer = 0;
    N = board.size();

    queue<Robot> q;
    unordered_set<Robot, MyHash> checked; // â­ë°©ë¬¸ ì²´í¬ë¥¼ í•´ì‹œí…Œì´ë¸”ë¡œâ­

    // ë¡œë´‡ì˜ ì‹œì‘ ìƒíƒœ
    // ì¼ë¶€1 : (0, 0) ë¡œë´‡ ì¤‘ì‹¬ì˜ ì™¼ìª½
    // ì¼ë¶€2 : (0, 1) ë¡œë´‡ ì¤‘ì‹¬ì˜ ì˜¤ë¥¸ìª½
    Robot start{ { 0, 0, LEFT }, { 0, 1, RIGHT }, 0 };
    checked.insert(start);
    q.push(start);

    while (!q.empty()) {
        // ë°©ë¬¸
        Robot now = q.front();
        q.pop();

        // ë¡œë´‡ì´ ëª©ì ì§€ì— ë„ì°©í–ˆë‹¤ë©´(ë¡œë´‡ì˜ ë‘ íŒŒíŠ¸ ì¤‘ í•˜ë‚˜ë¼ë„ ë„ì°©í–ˆë‹¤ë©´)
        if (now.part1.y == N - 1 && now.part1.x == N - 1 || now.part2.y == N - 1 && now.part2.x == N - 1) {
            answer = now.time;
            break;
        }

        /* ì˜ˆì•½ : ì´ë™ */
        for (int i = 0; i < 4; ++i) {
            Pos next_part_1{ now.part1.y + dy[i], now.part1.x + dx[i], now.part1.dir };
            Pos next_part_2{ now.part2.y + dy[i], now.part2.x + dx[i], now.part2.dir };
            Robot next{ next_part_1, next_part_2, now.time + 1 };

            if (!possible(board, next_part_1, next_part_2))
                continue;
            if (checked.find(next) != checked.end())
                continue;

            q.push(next);
            checked.insert(next);
        }

        /* ì˜ˆì•½ : íšŒì „ */
        if (now.part1.dir == LEFT) {
            Pos up_left{ now.part1.y - 1, now.part1.x, UP };
            Pos up_right{ now.part2.y - 1, now.part2.x, UP };
            if (possible(board, up_left, up_right)) {
                Robot next1{ up_left, { now.part1.y, now.part1.x, DOWN } , now.time + 1 };
                if (checked.find(next1) == checked.end()) {
                    q.push(next1);
                    checked.insert(next1);
                }
                Robot next2{ up_right, { now.part2.y, now.part2.x, DOWN } , now.time + 1 };
                if (checked.find(next2) == checked.end()) {
                    q.push(next2);
                    checked.insert(next2);
                }
            }
            Pos down_left{ now.part1.y + 1, now.part1.x, DOWN };
            Pos down_right{ now.part2.y + 1, now.part2.x, DOWN };
            if (possible(board, down_left, down_right)) {
                Robot next1{ { now.part1.y, now.part1.x, UP }, down_left, now.time + 1 };
                if (checked.find(next1) == checked.end()) {
                    q.push(next1);
                    checked.insert(next1);
                }
                Robot next2{ { now.part2.y, now.part2.x, UP } , down_right, now.time + 1 };
                if (checked.find(next2) == checked.end()) {
                    q.push(next2);
                    checked.insert(next2);
                }
            }
        }
        if (now.part1.dir == UP) {
            Pos left_up{ now.part1.y, now.part1.x - 1, LEFT };
            Pos left_down{ now.part2.y, now.part2.x - 1, LEFT };
            if (possible(board, left_up, left_down)) {
                Robot next1{ left_up, { now.part1.y, now.part1.x, RIGHT } , now.time + 1 };
                if (checked.find(next1) == checked.end()) {
                    q.push(next1);
                    checked.insert(next1);
                }
                Robot next2{ left_down, { now.part2.y, now.part2.x, RIGHT } , now.time + 1 };
                if (checked.find(next2) == checked.end()) {
                    q.push(next2);
                    checked.insert(next2);
                }
            }
            Pos right_up{ now.part1.y, now.part1.x + 1, RIGHT };
            Pos right_down{ now.part2.y, now.part2.x + 1, RIGHT };
            if (possible(board, right_up, right_down)) {
                Robot next1{ { now.part1.y, now.part1.x, LEFT } , right_up, now.time + 1 };
                if (checked.find(next1) == checked.end()) {
                    q.push(next1);
                    checked.insert(next1);
                }
                Robot next2{ { now.part2.y, now.part2.x, LEFT } , right_down, now.time + 1 };
                if (checked.find(next2) == checked.end()) {
                    q.push(next2);
                    checked.insert(next2);
                }
            }
        }
    }

    return answer;
}
```

![image](https://user-images.githubusercontent.com/42318591/113573512-3d506e80-9655-11eb-8e3b-d72a1a33c6ac.png)



***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}