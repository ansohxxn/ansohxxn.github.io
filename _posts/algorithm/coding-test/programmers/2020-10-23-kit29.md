---
title:  "[ê³ ë“ì Kit][DFS][BFS] ë‹¨ì–´ ë³€í™˜ â­â­â­" 

categories:
  - Programmers
tags:
  - [Algorithm, Coding Test, DFS, BFS]

toc: true
toc_sticky: true

date: 2020-10-23
last_modified_at: 2020-10-23
---
**C++**ë¡œ í’€ì´í–ˆìŠµë‹ˆë‹¤.  
ì¶œì²˜ : **í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ê³ ë“ì  Kit** ë¬¸ì œ í’€ì´. <https://programmers.co.kr/learn/challenges>
{: .notice--warning}

# [DFS][BFS] ë‹¨ì–´ ë³€í™˜

> ë‚œì´ë„ â­â­â­

## ë¬¸ì œ

![image](https://user-images.githubusercontent.com/42318591/96970817-332b2f80-154f-11eb-80d0-7522ad7bc24d.png)

<br>

## BFS ë¡œ í‘¼ í’€ì´ â­•

```cpp
#include <string>
#include <vector>
#include <queue>

using namespace std;

int differentCount(string str, string target) 
{
	int differentCount = 0;
	for (int i = 0; i < str.length(); i++)
	{
		if (str[i] != target[i])
			differentCount++;
	}
	return differentCount;
}

struct compare 
{
	bool operator() (pair<string, int> a, pair<string, int> b)
	{
		return a.second > b.second;
	}
};

int solution(string begin, string target, vector<string> words) {
	int answer = 0;

	priority_queue<pair<string, int>, vector<pair<string, int>>, compare> waiting_queue;
	vector<bool> pushedStr(words.size());

	waiting_queue.push(make_pair(begin, differentCount(begin, target)));

	while (!waiting_queue.empty()) 
	{
		begin = waiting_queue.top().first;
		waiting_queue.pop();

		if (begin == target) break;

		for (int i = 0; i < words.size(); i++)
		{
			if (!pushedStr[i] && differentCount(begin, words[i]) == 1)
			{
				waiting_queue.push(make_pair(words[i], differentCount(words[i], target)));
				pushedStr[i] = true;
			}
		}
		answer++;
	}

	if (begin != target) return 0;

	return answer;
}
```

<br>

## DFS ë¡œ í‘¼ í’€ì´ â­•

```cpp
#include <string>
#include <vector>

using namespace std;

bool canChangeWord(string a, string b)
{
	int differentCount = 0;
	for (int i = 0; i < a.length(); i++)
	{
		if (a[i] != b[i])
			differentCount++;
	}
	if (differentCount == 1) return true;
	else return false;
}

void DFS(vector<string> words, vector<bool> visited, int& answer, string target, string begin, int depth)
{
	if (begin == target)
    {
        answer = min(answer, depth);
        return;
    }

	for (int i = 0; i < words.size(); i++)
	{
		if (!visited[i] && canChangeWord(begin, words[i]))
		{
			visited[i] = true;
			DFS(words, visited, answer, target, words[i], depth + 1);
		}
	}
}

int solution(string begin, string target, vector<string> words) {
	int answer = 100;

	vector<bool> visited(words.size());

	DFS(words, visited, answer, target, begin, 0);

    if(answer == 100) return 0;
    else return answer;
}
```

***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}