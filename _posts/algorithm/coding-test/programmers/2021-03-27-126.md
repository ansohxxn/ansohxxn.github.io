---
title:  "[C++ë¡œ í’€ì´] ì¹´ë“œ ì§ ë§ì¶”ê¸° (ìˆœì—´ ì† ìˆœì—´, ì™„ì „íƒìƒ‰, DFS, BFS, DP)â­â­â­" 

categories:
  - Programmers
tags:
  - [Algorithm, Coding Test]

toc: true
toc_sticky: true

date: 2021-03-27
last_modified_at: 2021-03-27
---
**C++**ë¡œ í’€ì´í–ˆìŠµë‹ˆë‹¤.  
ì¶œì²˜ : **í”„ë¡œê·¸ë˜ë¨¸ìŠ¤** <https://programmers.co.kr/learn/challenges>
{: .notice--warning}

# ğŸ“Œ ì¹´ë“œ ì§ ë§ì¶”ê¸°

> ë‚œì´ë„ â­â­â­

## ğŸš€ ë¬¸ì œ

![image](https://user-images.githubusercontent.com/42318591/112717406-cff35e00-8f2f-11eb-9125-ea1238871f3f.png)

![image](https://user-images.githubusercontent.com/42318591/112717577-11d0d400-8f31-11eb-81fd-d64698192a71.png)

![image](https://user-images.githubusercontent.com/42318591/112717567-f6fe5f80-8f30-11eb-8aa7-e62ec5ab2989.png)

![image](https://user-images.githubusercontent.com/42318591/112717592-32009300-8f31-11eb-9927-8889c84ae6ea.png)

![image](https://user-images.githubusercontent.com/42318591/112717604-39c03780-8f31-11eb-9fa9-c2bc604cf8f2.png)


<br>

## ğŸš€ ë‚´ í’€ì´ 

### ğŸ”¥ DFS + BFS ì‚¬ìš©í•œ í’€ì´ â­•

```cpp
#include <string>
#include <vector>
#include <queue>

using namespace std;

#define INF 9999
int n = 0;
int answer = 0;
struct Pos {
    int r;
    int c;
};
int dirR[] = { 0, 0, -1, 1 };
int dirC[] = { 1, -1, 0, 0 };
vector<vector<Pos>> allCard(7);
vector<bool> numOfCard_visited(7);
vector<vector<bool>> singleCard_visited(7);

void SmallDFS(vector<vector<int>> board, vector<Pos> sameCards, int cardNum, Pos card, int dist, int small_depth, int big_depth);

vector<vector<Pos>> Categorize(vector<vector<int>> board) {
    vector<vector<Pos>> allCard(7);
    for (int i = 0; i < board.size(); ++i) {
        for (int j = 0; j < board[i].size(); ++j) {
            if (board[i][j] != 0) {
                allCard[board[i][j]].push_back({ i, j });
                n++;
            }
        }
    }
    n /= 2;

    for (int i = 0; i < allCard.size(); ++i) {
        vector<bool> v(allCard[i].size());
        singleCard_visited[i] = v;
    }
        
                
    return allCard;
}

int BFS(vector<vector<int>> board, Pos startCard, Pos destCard) {
    queue<Pos> q;
    vector<vector<bool>> checked(4, vector<bool>(4));
    vector<vector<int>> dist(4, vector<int>(4));

    q.push(startCard);
    checked[startCard.r][startCard.c] = true;
    dist[startCard.r][startCard.c] = 0;

    while (!q.empty()) {
        int nowR = q.front().r;
        int nowC = q.front().c;
        q.pop();

        for (int i = 0; i < 4; ++i) {
            int nextR = nowR + dirR[i];
            int nextC = nowC + dirC[i];

            if (nextR < 0 || nextC < 0 || nextR >= 4 || nextC >= 4)
                continue;
            if (checked[nextR][nextC])
                continue;

            q.push({ nextR, nextC });
            checked[nextR][nextC] = true;
            dist[nextR][nextC] = dist[nowR][nowC] + 1;
        }

        for (int i = 0; i < 4; ++i) {
            int nextR = nowR;
            int nextC = nowC;
            bool found = false;
            while (!found) {
                if (nextR + dirR[i] < 0 || nextC + dirC[i] < 0 || nextR + dirR[i] >= 4 || nextC + dirC[i] >= 4)
                    break;
                if (board[nextR + dirR[i]][nextC + dirC[i]] != 0) 
                    found = true;

                nextR += dirR[i];
                nextC += dirC[i];
            }

            if (checked[nextR][nextC])
                continue;

            q.push({ nextR, nextC });
            checked[nextR][nextC] = true;
            dist[nextR][nextC] = dist[nowR][nowC] + 1;
        }
    }

    return dist[destCard.r][destCard.c];
}

void BigDFS(vector<vector<int>> board, Pos card, int dist, int small_depth, int big_depth) {
    if (big_depth == n) {
        if (dist < answer)
            answer = dist;
        return;
    }

    for (int i = 1; i <= 6; ++i) {
        if (allCard[i].size() == 0)
            continue;
        if (numOfCard_visited[i] == false) {
            vector<Pos> sameCards = allCard[i];
            vector<bool>& sameCard_visited = singleCard_visited[i];
            SmallDFS(board, sameCards, i, card, dist, 0, big_depth);
            numOfCard_visited[i] = false;
        }
    }
}

void SmallDFS(vector<vector<int>> board, vector<Pos> sameCards, int cardNum, Pos card, int dist, int small_depth, int big_depth) {
    if (small_depth == 2) {
        dist += 2;
        bool flag = true;
        for (int i = 0; i < singleCard_visited[cardNum].size(); ++i) {
            if (singleCard_visited[cardNum][i] == false) {
                flag = false;
                break;
            }
        }
        if (flag)
            numOfCard_visited[cardNum] = true;
        BigDFS(board, card, dist, 0, big_depth + 1);
        return;
    }

    for (int i = 0; i < sameCards.size(); ++i) {
        if (singleCard_visited[cardNum][i] == false) {
            singleCard_visited[cardNum][i] = true;
            Pos nextCard{ sameCards[i].r, sameCards[i].c };
            int newDist = dist + BFS(board, card, nextCard);
            board[sameCards[i].r][sameCards[i].c] = 0;
            SmallDFS(board, sameCards, cardNum, nextCard, newDist, small_depth + 1, big_depth);
            board[sameCards[i].r][sameCards[i].c] = cardNum;
            singleCard_visited[cardNum][i] = false;
        }
    }
}

int solution(vector<vector<int>> board, int r, int c) {
    answer = INF;
    n = 0;
    allCard = Categorize(board);
    Pos start{ r, c };
    BigDFS(board, start, 0, 0, 0);
    return answer;
}
```

![image](https://user-images.githubusercontent.com/42318591/112717667-902d7600-8f31-11eb-9b8a-1a3c23c6d374.png)

ì½”ë“œ í•´ì„¤ ê³§ ì¶”ê°€ ì˜ˆì •!

<br>

#### âœˆ ë” ê¹”ë”í•œ ë‹¤ë¥¸ í’€ì´ í•´ì„¤!


```cpp
{% raw %}
#include <string>
#include <vector>
#include <queue>

using namespace std;
#define INF 987654321

struct Card {
    int row;
    int col;
    int count; // ì¡°ì‘ íšŸìˆ˜ 
};

vector<vector<int>> Board;
int D[4][2] = {{ -1, 0 }, {1, 0}, {0, -1}, {0, 1}}; // ìƒ,í•˜,ì¢Œ,ìš°

int bfs(Card start_card, Card dest_card) {
    bool checked[4][4] = { false };
    queue<Card> q;
    
    checked[start_card.row][start_card.col] = true;
    q.push(start_card);
    
    while (!q.empty()) {
        Card now_card = q.front();
        q.pop();
        
        if (now_card.row == dest_card.row && now_card.col == dest_card.col)
            return now_card.count;
        
        for (int i = 0; i < 4; ++i) {
            int next_row = now_card.row + D[i][0];
            int next_col = now_card.col + D[i][1];
            
            // ë°©í–¥í‚¤ ì´ë™
            if (next_row < 0 || next_row >= 4 || next_col < 0 || next_col >= 4) continue;
            if (!checked[next_row][next_col]) {
                checked[next_row][next_col] = true;
                q.push({ next_row, next_col, now_card.count + 1 });
            }
            
            // Ctrl ì´ë™
            for (int j = 0; j < 2; ++j) { 
                if (Board[next_row][next_col] != 0) break;  // ë‹¤ë¥¸ ì¹´ë“œ ë§Œë‚¬ë‹¤ë©´
                if (next_row + D[i][0] < 0 || next_row + D[i][0] >= 4 || next_col + D[i][1] < 0 || next_col + D[i][1] >= 4) break; // ëì— ë„ë‹¬í–ˆë‹¤ë©´
                
                next_row += D[i][0];
                next_col += D[i][1];
            }
            if (!checked[next_row][next_col]) {
                checked[next_row][next_col] = true;
                q.push({ next_row, next_col, now_card.count + 1 });
            }
        }
    }
    return INF;
}

int permutate(Card start_card) {
    int ret = INF;
    for (int num = 1; num <= 6; ++num) { // ì¹´ë“œëŠ” 1~6 ìˆì„ ìˆ˜ ìˆë‹¤. ì¹´ë“œ ë„˜ë²„ë³„ ì €ì¥
        vector<Card> card; // ë„˜ë²„ë³„ ê°™ì€ ì¹´ë“œë“¤ ì €ì¥í•  ê³³, í¬ê¸° 2
        for (int i = 0; i < 4; ++i) 
            for (int j = 0; j < 4; ++j) 
                if (Board[i][j] == num) 
                    card.push_back({i, j, 0});

        if (card.empty()) continue; // numì´ ì´ë¯¸ ì œê±°ëœ ì¹´ë“œ or í˜¹ì€ ì—†ëŠ” ì¹´ë“œ
        
        // ê°™ì€ ì¹´ë“œë¥¼ ìˆœíšŒí•˜ëŠ” 2ê°€ì§€ ë°©ë²•
        int one = bfs(start_card, card[0]) + bfs(card[0], card[1]) + 2; // a1 -> a2
        int two = bfs(start_card, card[1]) + bfs(card[1], card[0]) + 2; // a2 -> a1
        
        // ì¹´ë“œ ì œê±°
        for (int i = 0; i < 2; ++i)
            Board[card[i].row][card[i].col] = 0;
        
        // ê°€ì¥ ì‘ì€ê²Œ ret ì— ë‹´ê¸°ê²Œ ëœë‹¤. (ìµœëŒ€ 12ë²ˆ ë¹„êµ)
        ret = min(ret, one + permutate(card[1])); // a1 -> a2 ì„ ëë‚¸ í›„ ì´ì œ ë‹¤ë¥¸ ì¹´ë“œ ìˆœíšŒ
        ret = min(ret, two + permutate(card[0])); // a2 -> a1 ì„ ëë‚¸ í›„ ì´ì œ ë‹¤ë¥¸ ì¹´ë“œ ìˆœíšŒ
        
        // ëŒì•„ì™€ì„œ ë³µì› (ë‹¤ìŒ num ì„ íƒì„ ìœ„í•˜ì—¬)
        for (int i = 0; i < 2; ++i)
            Board[card[i].row][card[i].col] = num;
    }
    
    if (ret == INF) // ì´ ì¬ê·€ í˜¸ì¶œì—ì„œ ret ê°€ INF ì¼ ë•ŒëŠ” ëª¨ë“  ì¹´ë“œê°€ ì œê±°ëì„ ë•Œ! ëª¨ë“  ì¹´ë“œê°€ ì œê±°ëœ ìƒíƒœì¼ ë•ŒëŠ” ì¬ê·€ í˜¸ì¶œ ì¢…ë£Œ
        return 0;
    
    return ret;
}

int solution(vector<vector<int>> board, int r, int c) {
    Board = board;
    int answer = permutate({r, c, 0});
    return answer;
}
{% endraw %}
```


<iframe width="866" height="497" src="https://www.youtube.com/embed/4bwz9yOUGWM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<br>

### ğŸ”¥ DPë¥¼ ì‚¬ìš©í•œ í’€ì´ â­•

***
<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}