---
title:  "[C++, OpenGL] 2.5 ëª…ë ¹ íŒ¨í„´ Command Pattern" 

categories:
  - C++ games
tags:
  - [Programming, Cpp, OpenGL, Graphics, Design Pattern]

toc: true
toc_sticky: true

date: 2020-06-09
last_modified_at: 2020-06-09
---

ì¸í”„ëŸ°ì— ìˆëŠ” í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ **í™ì •ëª¨ì˜ ê²Œì„ ë§Œë“¤ê¸° ì—°ìŠµ ë¬¸ì œ íŒ¨í‚¤ì§€** ê°•ì˜ë¥¼ ë“£ê³  ì •ë¦¬í•œ í•„ê¸°ì…ë‹ˆë‹¤.ğŸ˜€   
[ğŸŒœ ê³µë¶€ì— ì‚¬ìš©ëœ í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ ì½”ë“œë“¤ ë³´ëŸ¬ê°€ê¸°](https://github.com/jmhong-simulation/GameDevPracticePackage)   
[ğŸŒœ [í™ì •ëª¨ì˜ ê²Œì„ ë§Œë“¤ê¸° ì—°ìŠµ ë¬¸ì œ íŒ¨í‚¤ì§€] ê°•ì˜ ë“¤ìœ¼ëŸ¬ ê°€ê¸°!](https://www.inflearn.com/course/c-2)
{: .notice--warning}

<br>

# Chapter 2. ê°ì²´ ì§€í–¥ìœ¼ë¡œ ê°€ëŠ” ê¸¸ : ëª…ë ¹ íŒ¨í„´
- ëª…ë ¹ê³¼ í–‰ìœ„ ìì²´ë¥¼ ê°ì²´ë¡œ ë§Œë“¬
- <u>ì¶”ìƒí™”</u> í•´ë‚˜ê°€ëŠ” ê³¼ì •
- [í¬íƒ„ ì—¬ëŸ¬ê°œ ì˜ëŠ” íƒ±í¬ êµ¬í˜„í•˜ê¸°](https://ansohxxn.github.io/c++%20games/chapter1-3-prac/#-q1-%ED%8F%AC%ED%83%84-%EC%97%AC%EB%9F%AC%EA%B0%9C-%EC%8F%98%EB%8A%94-%ED%83%B1%ED%81%AC-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0) í¬ìŠ¤íŠ¸ì—ì„œ êµ¬í˜„í–ˆë˜ ì½”ë“œë¥¼ ì¬ì‚¬ìš© í•  ê²ƒì´ë‹¤.

## ğŸ”” ì „ì²´ ì½”ë“œ
1. class Actor
2. class Command
3. class Upcommand
4. class MyTank
  - Actor ìƒì† ë°›ìŒ
  - íƒ±í¬ ê°ì²´ë¥¼ ìƒì„±í•˜ê³  ê·¸ë¦¼ draw
5. class InputHandler
6. class TankExample
  - Game2Dë¥¼ ìƒì† ë°›ì•„ update ëŒë¦¬ëŠ” ì£¼ìš” í´ë˜ìŠ¤

```cpp
#pragma once

#include "Game2D.h"
#include <map>

namespace jm
{
	class *Actor*
	{
	public:
		virtual void moveUp(float dt) = 0;  // dt ì‹œê°„ì— ë¹„ë¡€í•˜ì—¬ ì´ë™
	};

	class *Command*
	{
	public:
		virtual ~Command() {}
		virtual void execute(Actor& actor, float dt) = 0;
	};

	class UpCommand : public Command 
	{
	public:
		virtual void execute(Actor& actor, float dt) override
		{
			actor.moveUp(dt);
		}
	};

	class MyTank : public Actor
	{
	public:
		vec2 center = vec2(0.0f, 0.0f);
		//vec2 direction = vec2(1.0f, 0.0f, 0.0f);

		void moveUp(float dt) override
		{
			center.y += 0.5f * dt;
		}

		void draw()
		{
			beginTransformation();
			{
				translate(center);
				drawFilledBox(Colors::green, 0.25f, 0.1f); // body
				translate(-0.02f, 0.1f);
				drawFilledBox(Colors::blue, 0.15f, 0.09f); // turret
				translate(0.15f, 0.0f);
				drawFilledBox(Colors::red, 0.15f, 0.03f);  // barrel
			}
			endTransformation();
		}
	};

	class InputHandler
	{
	public:
		Command * button_up = nullptr;

		//std::map<int, Command *> key_command_map;

		InputHandler()
		{
			button_up = new UpCommand;
		}

		void handleInput(Game2D & game, Actor & actor, float dt)
		{
			if (game.isKeyPressed(GLFW_KEY_UP))  button_up->execute(actor, dt);

			/*for (auto & m : key_command_map)
			{
				if (game.isKeyPressed(m.first)) m.second->execute(actor, dt);
			}*/
		}
	};

	class TankExample : public Game2D
	{
	public:
		MyTank tank;

		InputHandler input_handler;

	public:
		TankExample()
			: Game2D("This is my digital canvas!", 1024, 768, false, 2)
		{
			//key mapping
			//input_handler.key_command_map[GLFW_KEY_UP] = new UpCommand;
		}

		~TankExample()
		{
		}

		void update() override
		{
			// move tank
			/*if (isKeyPressed(GLFW_KEY_LEFT))	tank.center.x -= 0.5f * getTimeStep(); // ì›ë˜ ì´ë ‡ê²Œ êµ¬í˜„í–ˆëŠ”ë° ì´ë ‡ê²Œ í•˜ë©´
			if (isKeyPressed(GLFW_KEY_RIGHT))	tank.center.x += 0.5f * getTimeStep();  // íƒ±í¬ê°€ ì•„ë‹Œ ì „íˆ¬ê¸°ë¡œ ë°”ê¾¸ê³ ì‹¶ë‹¤ë©´
			if (isKeyPressed(GLFW_KEY_UP))		tank.center.y += 0.5f * getTimeStep();  // ì½”ë“œë¥¼ ì „ë¶€ êµì²´í•´ì•¼í•˜ëŠ” ë¶ˆí¸í•¨ æœ‰
			if (isKeyPressed(GLFW_KEY_DOWN))	tank.center.y -= 0.5f * getTimeStep();*/ 

			input_handler.handleInput(*this, tank, getTimeStep());

			// rendering
			tank.draw();
		}
	};
}
```

<br>

    ğŸŒœ ê°œì¸ ê³µë¶€ ê¸°ë¡ìš© ë¸”ë¡œê·¸ì…ë‹ˆë‹¤. ì˜¤ë¥˜ë‚˜ í‹€ë¦° ë¶€ë¶„ì´ ìˆì„ ê²½ìš° 
    ì–¸ì œë“ ì§€ ëŒ“ê¸€ í˜¹ì€ ë©”ì¼ë¡œ ì§€ì í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤! ğŸ˜„

[ë§¨ ìœ„ë¡œ ì´ë™í•˜ê¸°](#){: .btn .btn--primary }{: .align-right}